### Cats with Scala

- `Working with type classes in Scala` means `working with implicit values and implicit parameters`
- There are three important components to the type class pattern:
  - `type class`
  - `instances` for particular types
  - `methods` that use `type classes`.
- `the components of type classes`:
  - traits: `type classes`
  - implicit values: type class `instances`
  - implicit parameters: type class `use`:
    - any functionality that requires a `type class instance` to work. In Scala this means any `method` that accepts instances of the type class as implicit parameters.
  - implicit classes: optional utilities that make type classes easier to use
- `implicit scope`:
  - when given `Json.toJson("A string!")` compiler searches:
    - `local or inherited definitions`
    - `imported definitions`
    - `definitions in the companion object of the type class or the parameter type (in this case JsonWriter(Type Class) or String(Parameter Type)).`
- `contravariance`: the `type F[B]` is a subtype of `F[A]` if `A` is a subtype of `B`. (1.6.1)
- Cats use `invariant`:
  - `Covariant`: picks `More specific type `
  - `Contravariant`: picks `Supertype instance`
  - if you'd like to specify more specific instances for subtypes, you can use annotation (such as `Some(1): Option[Int]`) or use "smart constructors" like the `Option.apply`(an apply method for materializing instances. Default instances are provided via objects in the `cats.instances `package)(1.6)
- `Monoids` and `Semigroups`
  - `closed`: adding two `Ints` always producds another `Int`
  - `identity element`: such as 0 for addition, because `2 + 0 == 2`, `0 + 2 == 2` for any `Int`. 1 as the identity for multiplication. And empty string `""` is identity for `Strings`
  - `associativity`: means it doesn't matter in what order we add elements because we always get the same result.
    - for Strings, `("One" + "Two") + "Three"` and `"One" + ("Two" + "Three")` are the same, thus it's associative.
- `Eventual consistency`: In a distributed system, different machines may end up with different views of data. For example, one machine may receive an update that other machines did not receive. We would like to reconcile these different views, so `every machine has the same data if no more updates arrive`.
- A particular class of data types support this reconciliation. These data types are called `commutative replicated data types` (`CRDTs`). The key operation is the ability to merge two data instances, with `a result that captures all the information in both instances`. This operation relies on having a `monoid instance`.
- Functors:
  - `classes that encapsulates sequencing computations`
  - `Functor Laws`:
    - `Identity`: calling map with the identity function is the same as doing nothing:
      - `fa.map(a => a) == fa`
    - `Composition`: mapping with two functions `f` and `g` is the same as mapping with `f` and then mapping with `g`:
      - `fa.map(g(f(_))) == fa.map(f(_)).map(g)`
  - map is a way of sequencing computations on values:
    - `Option` — the value may or may not be present;
    - `Either` — there may be a value or an error;
    - `List` — there may be zero or more values.
- Future Warning:
  - Future may not be `referential transparency`.
  - Future always starts computations immediately rather than allowing the user to dictate when the program should run. For more information see this excellent [Reddit answer by Rob Norris](https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/):
    - When we look at `Cats Effect` we’ll see that the IO type solves these problems.
- `Kinds` are like `types for types`. They describe the number of `'holes' in a type`:
  - We distinguish between `regular types that have no holes` and `'type constructors' that have holes we can fill to produce types`.
  - `List`: type constructor(or `higher kinded type`):
    - In Scala we declare type constructors using underscores:
      - `def myMethod[F[_]] = { ... }`
  - `List[Int]`: regular type
  - `List[A]`: regular type, but generic type as well.
- `Monad`:
  - a mechanism for sequencing computations(Monads are all about sequencing).
  - `pure` abstracts over constructors, providing `a way to create a new monadic context from a plain value`.
  - `Monad Laws`:
    - `Left identity`: calling pure and transforming the result with func is the same as calling func:
      - `pure(a).flatMap(func) == func(a)`
    - `Right identity`: passing pure to flatMap is the same as doing nothing:
      - `m.flatMap(pure) == m`
    - `Associativity`: flatMapping over two functions f and g is the same as flatMapping over f and then flatMapping over g:
      - `m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))`
- `Eval`:
  - `call-by-need evaluation`: `a result to be memoized`
  - `stack-safe`: we can use it in very deep recursions without blowing up the stack.
    - we must bear in mind that `trampolining is not free`. It avoids consuming `stack` `by creating a chain of function objects on the heap`. There are still limits on how deeply we can nest computations, but `they are bounded by the size of the heap rather than the stack`.
- `Writer Monad`:
  - Deal with log and result at one time, but either of them is always optional to deal with.
  - With `Writer` the `log` for the computation is tied to the `result`, so `we can run concurrent computations without mixing logs`!!
  - We can extract the `result` and `log` from a Writer using the `value` and `written` methods respectively:
- `State`:
  - `an instance of State` is a `function` that does two things:
    - transforms an input state to an output state
    - computes a result
  - `run`: `run our monad by supplying an initial state`.
    - `runS`: get the state, ignore the result
    - `runA`: get the result, ignore the state
- `flatMap` can be viewed as an `operator for sequencing computations`, dictating the order in which operations must happen. From this viewpoint:

  - `Option` represents a computation that can fail without an error message
  - `Either` represents computations that can fail with a message
  - `List` represents multiple possible results
  - `Future` represents a computation that may produce a value at some point in the future.

- `Monad Transformer`:
  - `The monad transformer classes`:
    - `OptionT` for Option
    - `EitherT` for Either
    - `ReaderT` for Reader
    - `WriterT` for Writer
    - `StateT` for State
    - `IdT` for Id
  - build `Monad stacks` from the inside out:
    - `type ListOption[A] = OptionT[List, A]` (List -> Option from inside)
- `What Functor and Monad can't`:
  1. they can't return all errors, thus they're not for form `validation`.
  2. `map` and `flatMap` aren’t quite capable of capturing what we want because they make the assumption that `each computation is dependent on the previous one`, so they can't computation concurrently.
- `Semigroupal`: a type class that allows us to `combine contexts`. If we have two objects of type `F[A]` and `F[B]`, a `Semigroupal[F]` allows us to combine them to form an `F[(A, B)]` -> the order of these objects doesn't matter.
  - `Semigroupal Laws`: the `product method` must be `associative`.
    - `product(a, product(b, c)) == product(product(a, b), c)`
  - `tupled` method: implicitly added to the tuple of `Options`. It uses the `Semigroupal` for `Option` to zip the values inside the `Options`, creating a single `Option of a tuple`:
    - `(Option(123), Option("abc")).tupled`
  - `mapN`: accepts an `implicit Functor` and a function of the correct arity to `combine` the values.
