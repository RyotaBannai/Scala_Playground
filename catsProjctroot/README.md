### Cats with Scala

- `Working with type classes in Scala` means `working with implicit values and implicit parameters`
- There are three important components to the type class pattern:
  - `type class`
  - `instances` for particular types
  - `methods` that use `type classes`.
- `the components of type classes`:
  - traits: `type classes`
  - implicit values: type class `instances`
  - implicit parameters: type class `use`:
    - any functionality that requires a `type class instance` to work. In Scala this means any `method` that accepts instances of the type class as implicit parameters.
  - implicit classes: optional utilities that make type classes easier to use
- `implicit scope`:
  - when given `Json.toJson("A string!")` compiler searches:
    - `local or inherited definitions`
    - `imported definitions`
    - `definitions in the companion object of the type class or the parameter type (in this case JsonWriter(Type Class) or String(Parameter Type)).`
- `contravariance`: the `type F[B]` is a subtype of `F[A]` if `A` is a subtype of `B`. (1.6.1)
- Cats use `invariant`:
  - `Covariant`: picks `More specific type `
  - `Contravariant`: picks `Supertype instance`
  - if you'd like to specify more specific instances for subtypes, you can use annotation (such as `Some(1): Option[Int]`) or use "smart constructors" like the `Option.apply`(an apply method for materializing instances. Default instances are provided via objects in the `cats.instances `package)(1.6)
- `Monoids` and `Semigroups`
  - `closed`: adding two `Ints` always producds another `Int`
  - `identity element`: such as 0 for addition, because `2 + 0 == 2`, `0 + 2 == 2` for any `Int`. 1 as the identity for multiplication. And empty string `""` is identity for `Strings`
  - `associativity`: means it doesn't matter in what order we add elements because we always get the same result.
    - for Strings, `("One" + "Two") + "Three"` and `"One" + ("Two" + "Three")` are the same, thus it's associative.
- `Eventual consistency`: In a distributed system, different machines may end up with different views of data. For example, one machine may receive an update that other machines did not receive. We would like to reconcile these different views, so `every machine has the same data if no more updates arrive`.
- A particular class of data types support this reconciliation. These data types are called `commutative replicated data types` (`CRDTs`). The key operation is the ability to merge two data instances, with `a result that captures all the information in both instances`. This operation relies on having a `monoid instance`.
- Fanctors:
  - map is a way of sequencing computations on values:
    - `Option` — the value may or may not be present;
    - `Either` — there may be a value or an error;
    - `List` — there may be zero or more values.
- Future Warning:
  - Future may not be `referential transparency`.
  - Future always starts computations immediately rather than allowing the user to dictate when the program should run. For more information see this excellent [Reddit answer by Rob Norris](https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/):
    - When we look at `Cats Effect` we’ll see that the IO type solves these problems.
