### scalaの型
- 型宣言必要ない(代入したときに**型推論**) `var | val` var は後から変更可で、valは変更不可. 基本的にはvalを使用.
- `var`に初めに数値を入れると、後から文字列を代入できない（これはtypescriptと同じ様な型制限）
- `val x: Int = 3 * 3` 型宣言の場合。
### sbtを使う
- sbtでmainがある場所で`sbt`と打つ
- `run`コマンドを打つ。mainが複数ある場合は選択するプロントが表示される。
- `sbt console`でインタラクティブモードに入る. ここで作ったクラスとかファイルを全て読み込めるため、クラスの動作確認ができる.
- src/User.scala　に記述した物を実行
```scala
val u = new User("dwango", 13)
User.printUser(u)
```
### 制御構文
- **Unit 型**はJavaでは`void`に相当するもので、返すべき値がない時に使われ、唯一の値()を持つ.
- elseが省略可能で、その場合は、**Unit 型**の値 () が補われたのと同じ値が返る.
- break やcontinueなどの言語機能`はない.
- return 式はメソッドから、途中で脱出してメソッドの呼び出し元に返り値を返すための制御構文
- return 式はメソッドから、途中で脱出してメソッドの呼び出し元に返り値を返すための制御構文である.
- `1 to 10 `は1から10まで（10を含む）の範囲で、 `1 until 10` は1から10まで（10を含まない）の範囲
- for + yield で `for-comprehension`
- Scalaのパターンマッチがいわゆる**フォールスルー（fall through）** の動作をしない
- パターンマッチの後にガード式（Boolean型でないといけない）が使える
```scala
mylist match{
  case List("A", b, c) if b != "B" =>
    println("Hit!")
  case _ =>
    println("Not hit!")
    }
```
- @の後に続くパターンにマッチする式を @ の前の変数に束縛する. as パターンはパターンが複雑なときにパターンの一部だけを切り取りたい時に便利.
- ただし | を使ったパターンマッチの場合は値を取り出すことができない. ワイルドカード_を使う.
- `"A" :: b :: c :: _` のように、リストの要素の間にパターン名（::）が現れるようなものを**中置パターン**と呼ぶ.
- `AnyRef`型は、Javaの`Object`型に相当する型で、**あらゆる参照型の値**をAnyRef型の変数に格納することができる.
- 型でマッチした値は、その型にキャストしたのと同じように扱うことができる. しばしばScalaではキャストの代わりにパターンマッチが用いられるので覚えておくとよい.
- JVMの制約による型のパターンマッチの落とし穴: Scalaを実行するJVMの制約により、型変数を使った場合、正しくパターンマッチが行われない。
```scala
val obj: Any = List("a")
obj match {
  case v: List[Int]    => println("List[Int]")
  case v: List[String] => println("List[String]")
}
```
- 型としては`List[Int]`と`List[String]`は違う型なのですが、パターンマッチではこれを区別できない。最初の2つの警告の意味はScalaコンパイラの **「型消去」** という動作により`List[Int]`のIntの部分が消されてしまうのでチェックされないということ。結果的に2つのパターンは区別できないものになり、パターンマッチは上から順番に実行されていくので、2番目のパターンは到達しないコードになる。3番目の警告はこれを意味している。型変数を含む型のパターンマッチは、以下のようにワイルドカードパターンを使うと良い。
```scala
obj match {
  case v: List[_] => println("List[_]")
}
```